\documentclass[10pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[polish]{babel}
\usepackage[T1]{fontenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{epsf} 
\nonstopmode

\title{Flow-Shop Scheduling\\Laboratorium Optymalizacji Kombinatorycznej}

\author{Szymon Gramza\\
  szymon.gramza@student.put.poznan.pl
\and
  Maciej Sobkowski\\
  maciej.sobkowski@student.put.poznan.pl
\and
  Prowadzący: Marcin Radom
}

\begin{document}
\maketitle
\section{Wprowadzenie}
\subsection{Opis problemu}
Problem Flow-Shop jest problemem optymalizacji kobminatorycznej, który polega na
szeregowaniu zadań przy wykorzystaniu ustalonej liczby maszyn. Każde zadanie
składa się z listy operacji, które muszą zostać wykonane w określonej kolejności
na określonej maszynie, a każdą operację cechuje czas wykonywania. Zadania
pojawiają się w różnych momentach pracy systemu, a maszyny na których są
wykonywane posiadają wymuszone przestoje.  Do rozwiązania powyższego problemu
wykorzystaliśmy zainspirowaną zachowaniem się mrówek poszukujących pożywienia
metaheurystykę ACO\@. Algorytm mrówkowy będziemy porównywać z rozwiązaniem
uzyskanym za pomocą algorytmów losowego oraz rozwiązaniem optymalnym obliczonym
za pomocą wzoru: 
\[ opt = \frac{\text{suma\ czasów\ wszystkich
operacji}}{\text{liczba\ maszyn}} \]

\subsection{Program testujący}

\subsubsection{Opis}
Aplikacja została napisana w języku C i wykorzystuje biblioteki dostępne w
systemach z rodziny GNU/Linux. 

\subsubsection{Kompilacja}
Kompilacja została zautomatyzowana przy pomocy programu GNU Make. Aby
skompilować program należy przejść do katalogu \textit{scheduler} i z poziomu 
konsoli wydać polecenie \textit{make}. Prawidłowe zakończenie procesu kompilacji 
zostanie zasygnalizowane komunikatem \textit{Zakończono linkowanie!}. W ten sam
sposób należy przebiega kompilacja programu \textit{generator}.

\subsubsection{Uruchomienie}
Praca aplikacji jest sterowana przez przełączniki powszechnie stosowane w
oprogramowaniu linuksowym.  Przykładowe wywołanie \textit{scheduler -i
inst\_name -o file\_name.csv} uruchomi program dla instancji zapisanej w pliku
inst\_name i wykona algorytm ACO oraz losowy. Wynik szeregowania zostanie
zapisany do pliku o nazwie file\_name.csv.  Dodatkowo, aby uruchomić program
generujący instancje należy użyć polecenia \textit{./generator}.\\ Przykładowe wywołanie:
\textit{./generator -i input\_name -o inst\_name } spowoduje wygenerowanie pliku
instancji inst\_name przyjmując parametry zawarte w pliku input\_name zgodnie ze
schematem, że każda linia składa się z 5 liczb całkowitych, które odpowiednio
charakteryzują: liczbę zadań, początek i koniec przedziału czasu wykonania
operacji, początek i koniec przedziału czasu gotowości zadania.\\ Generator
losuje czasy wykonania operacji i czasy gotowości dla zdefiniowanej liczby
zadań.

\section{Algorytm Ant Colony Optimization}

\subsection{Opis algorytmu}
Zastosowana przez nas metaheurystyka - Ant Colony Optimization - opiera się na
naturalnym zachowaniu kolonii mrówek poszukujących pożywienia. Algorytm korzysta
ze struktur utrzymujących informację o drodze od źródła do celu, przebytej przez
każdą mrówkę danego pokolenia. Algorytm został zaprojektowany do problemów
znajdowania ścieżki w grafie o najmniejszym koszcie (problem TSP).
Przystosowanie algorytmu do problemu szeregowania zadań sprowadza się w naszym
przypadku do przedstawienia operacji danej instancji w postaci grafu, którego
przykład umieszczono poniżej:\\
\begin{center}
    \includegraphics[scale=0.4]{./figures/pic01.png}\\
\end{center}
Każdemu wierzchołkowi grafu przyporządkowana jest jedna operacja, każda
operacja zaś posiada informacje o maszynie i numerze zadania.  Zależności
pomiędzy kolejnością wykonania operacji reprezentują łuki między nimi, ponadto
graf posiado dwa dodatkowe wierzchołki - początkowy i końcowy - które pozwalają
przypisać pierwszej i ostatniej operacji feromon. Dzięki takiej reprezentacji
problemu możemy korzystać z wzorów przeznaczonych dla algorytmu TSP z drobnymi
modyfikacjami.

Informacje o ilości feromonów utrzymywane są w macierzy NxN (N - liczba
operacji).  Rozwiązaniem generowanym przez mrówkę jest łańcuch wszystkich
wierzchołków zachowujący zależnosci między operacjami w zadaniu.  (sortowanie
topologiczne) Przykładowy łańcuch: [0 1 4 2 7 5 8 3 6 9 10].

Przed uruchomieniam właściwego algorytmu, początkowa ilość feromonu na każdej
ścieżce przyjmuje bardzo małą wartość, w naszej implementacji przyjęliśmy $
\tau_0 = 0.001 $ 

\subsubsection{State Transition Rule}
Każda mrówka wybierając drogę stosuję regułę zmiany stanu (State Transition
Rule), którą obrazuje poniższy wzór:\\

\begin{equation}
 s = \left\{ 
  \begin{array}{l l}
    arg\ max_{u \in J(r)} \{ [\tau (r,u)] \cdot [\eta (r,u)^\beta] \} , & \quad
    \text{jeśli $q\leq q_0$}\\
    S, & \quad \text{w przeciwnym razie}
  \end{array} \right.
\end{equation} \\
gdzie:
\begin{itemize}
  \item $ (r,u) $ - łuk od wierzchołka r do u
  \item $ J(r) $ - zbiór wierzchołków dostępnych w punkcie decyzyjnym r
  \item $ \tau (r,u) $ - ilość feromonu na łuku (r,u)
  \item $ \eta (r,u) $ - atrakcyjność łuku (r,u), która w przypadku naszego
    problemu zdefiniowana jest jako odwrotność długości operacji u
  \item $ \beta $ - parametr kontrolujący wpływ atrakcyjności
  \item $ q $ - losowa liczba z przedziału $ \langle 0;1 \rangle $ 
  \item $ q_0 $ - zdefiniowany parametr przyjmujący wartości z przedziału $
    \langle 0;1 \rangle $
  \item $ S $ - zmienna losowa wybierana zgodnia z rozkładem prawdopodobieństwa
    opisanym wzorem (2). 
\end{itemize}
\\
\begin{equation}
 P(r,s) = \left\{ 
  \begin{array}{l l}
    \frac{[\tau (r,s)] \cdot [\eta (r,s)^\beta]}{\sum_{u \in J(r)} {[\tau (r,u)]
    \cdot [\eta (r,u)^\beta]}},
    & \quad \text{jeśli }s \in J(r)\\
     0, & \quad \text{w przeciwnym razie}
  \end{array} \right.
\end{equation}

Powyższa metoda wyboru nosi nazwę pseudoruletki, której zasada działania opiera
się na przydzieleniu wartości procentowej koła ruletki, odpowiadającej
iloczynowi ilości feromonu i atrakcyjności. Po zakręceniu kołem, które jest
równoważne wylosowaniu liczby, wybierany jest następny wierzchołek na drodze
mrówki.

\subsubsection{Aktualizacja wartości feromonów}
W algorytmie stosujemy dwie strategie aktualizacji feromonów: \\
\begin{enumerate}
  \item lokalna (local updating rule) - w czasie konstruowania ścieżki mrówka
    modyfikuje ilosć feromonu stosując się do poniższego wzoru:\\
  \[ \tau (r,s) \leftarrow (1 - \rho) \cdot \tau (r,s) + \rho \cdot \tau_0  \] \\
  gdzie:
  \begin{itemize}
  \item $ \rho $ - współczynnik parowania feromonu (z przedziału $ (0;1) $)
\end{itemize}

  \item globalna (global updating rule) - gdy wszystkie mrówki danej populacji
    dotrą do celu (osiągną końcowy wierzchołek grafu) wartość feromonu jest
    aktualizowana zgodnie ze wzorem:\\
   \[ \tau (r,s) \leftarrow (1 - \alpha) \cdot \tau (r,s) + \alpha \cdot \Delta \tau (r,s)  \] \\
  gdzie:
  \begin{itemize}
  \item $ \alpha $ - parametr zaniku feromonu
  \item $ \Delta \tau (r,s) $ - przedstawia się wzorem: \\
  \begin{equation}
 \Delta \tau (r,s) = \left\{ 
  \begin{array}{l l}
    (L_{gb})^{-1} , & \quad \text{jeśli $(r,s) \in$ najlepsza ścieżka}\\
    0, & \quad \text{w przeciwnym razie}
  \end{array} \right.
\end{equation}
  gdzie:
  \item $ L_{gb}$ - długość najlepszej ścieżki ($C_{max}$)
\end{itemize}
\end{enumerate}

\subsection{Instancje testowe}
Każda znajdująca się poniżej instancja sterowana jest następującymi
parametrami: $ \rho, \alpha, q_0, \tau_0, \beta $.  Klasy instancji
podzieliliśmy na 4 grupy w zależności od rodzaju danych wejściowych: losowe,
rosnące, malejące, v-kształtne.

\newpage
\subsubsection{Grupa instancji 1}
Różne klasy instancji danych wejściowych.

\begin{center}
\begin{tabular}{|r|l|}
  \hline
  liczba zadań & 50 \\
  czasy operacji & $ \langle 5;100 \rangle $  \\
  liczba mrówek & 10 \\
  liczba pokoleń & 5000 \\
  $ \rho $ & 0,01 \\
  $ \alpha $ & 0,1 \\
  $ q_0 $ & 0,8 \\
  $ \tau_0 $ & 0,001 \\
  $ \beta $ & 2 \\
  \hline
\end{tabular}
\end{center}

\begin{figure}[h]
    \centering
    \includegraphics{./figures/inst01_rnd_smooth.pdf}
    \caption{Losowe}
\end{figure}

Wyczerpujący opis wykresu


\newpage
\begin{figure}[h]
    \centering
    \includegraphics{./figures/inst02_asc_smooth.pdf}
    \caption{Rosnące}
\end{figure}

\newpage
\begin{figure}[h]
    \centering
    \includegraphics{./figures/inst03_dsc_smooth.pdf}
    \caption{Malejące}
\end{figure}


\newpage
\begin{figure}[h]
    \centering
    \includegraphics{./figures/inst04_vsh_smooth.pdf}
    \caption{V-kształtne}
\end{figure}


\newpage
\subsubsection{Grupa instancji 2}
Różne wartości parametru $\beta$.

\begin{center}
\begin{tabular}{|r|l|}
  \hline
  klasa instancji & losowa \\
  liczba zadań & 50 \\
  czasy operacji & $ \langle 5;100 \rangle $  \\
  liczba mrówek & 10 \\
  liczba pokoleń & 5000 \\
  $ \rho $ & 0,01 \\
  $ \alpha $ & 0,1 \\
  $ q_0 $ & 0,8 \\
  $ \tau_0 $ & 0,001 \\
  \hline
\end{tabular}
\end{center}

\begin{figure}[h]
    \centering
   % \includegraphics{./figures/inst01_rnd_beta.pdf}
    \caption{$ \beta = \{ 0, 2, 4, 6 \} $}
\end{figure}


\newpage
\subsubsection{Grupa instancji 3}
Różne wartości parametru $\alpha$.


\end{document}
